<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../asq-base/asq-base.html">
<link rel="import" href="../asq-match/asq-matchable.html">


<!--
`asq-buckets-q` is a kind of matching question. To use this question, you need to difine two sets, `X` set and `Y` set, using `x-matchable` and `y-matchable`.

Users can make matches between `X` and `Y` set. The matches can be either `1-m` and `1-1` relation, by specifing `mode` attribute.


Examples:
    
    <asq-buckets-q 
      mode="1-2" 
      x-matchable="div[bucket]" 
      y-matchable="div[label]" 
      attr-for-matched="s-name"
      matched-attribute="matched"
      label-container="[labels]"
      matched-class="label-success">

      <div buckets>
        <div s-name="china" bucket><b>china</b></div>
        <div s-name="france" bucket><b>france</b></div>
        <div s-name="kroea" bucket><b>kroea</b></div>
      </div>
      
      <div labels>
        <div s-name="sun" label class="label-primary">sun</div>
        <div s-name="moon" label class="label-primary">moon</div>
        <div s-name="sky" label class="label-primary">sky</div>
        <div s-name="mar" label class="label-primary">mar</div>
        <div s-name="info" label class="label-primary">info</div>
        <div s-name="2000" label class="label-primary">2000</div>
      </div>
    </asq-buckets-q>



@element asq-asq-buckets-q
@demo demo/index.html
@group ASQ Elements
@blurb ASQ buckets questions.
@homepage http://github.com/ASQ-USI-Elements/asq-buckets-q
-->
<dom-module id="asq-buckets-q">
  
  <style is="custom-style">
    :host {
      display: block;
    }
  </style>

  <template>
    <template is="dom-if" if="{{hasRole(role, roles.VIEWER)}}" restamp>
      <content select="*"></content>
    </template>

    <template is="dom-if" if="{{hasRole(role, roles.PRESENTER)}}" restamp>
      <p>presenter viewer</p>
    </template>
    
  </template>

  <script>
    Polymer({
      is: 'asq-buckets-q',

      behaviors: [
        ASQ.asqQuestionElementBehavior,
        ASQ.MatchableBehavior
      ],

      created: function() {
        this.listen(this, 'asq-matched', '_onMatched');
      },

      attached: function() {
        this.async(function() {
          this._initItems();
        })
      },

      _labelContainer: undefined,


      properties: {
        onDraggingClass: {
          type: String,
          value: 'dragging',
          notify: true
        },

        labelContainer: {
          type: String,
          value: '',
          observer: '_labelContainerChanged'
        }
      },

      hasRole: function (role, candidate) {
        return role == candidate;
      },

      _labelContainerChanged: function() {
        var container = Polymer.dom(this).querySelector(this.labelContainer);

        this._labelContainer = container ? container : this;
      },

      _initItems: function() {

        this.xItems.forEach(function(x) {
          x.addEventListener('dragenter', this._onDragEnter);
          x.addEventListener('dragleave', this._onDragLeave);
          x.addEventListener('dragover', this._onDragOver);
          x.addEventListener('drop', this._onDrop.bind(this));
        }, this);

        this.yItems.forEach(function(y) {
          y.setAttribute('draggable', true);

          y.addEventListener('dragstart', this._onDragStart.bind(this));
          y.addEventListener('dragend', this._onDragEnd.bind(this));
          
        }, this);


        // 
        document.body.addEventListener('drop', this._onDropOut.bind(this));

        document.body.addEventListener('dragenter', function(e) {
          if (e.preventDefault) e.preventDefault(); 
        });

        document.body.addEventListener('dragover', function(e) {
          if (e.preventDefault) e.preventDefault(); 
          return false
        });
      },

      _onDragStart: function(e) {
        if ( this.onDraggingClass ) 
          e.currentTarget.classList.toggle(this.onDraggingClass, true);

        var data = this._valueForItem(e.currentTarget);

        // store the current bucket
        var parentElement = e.target.parentElement;
        if ( this.xItems.indexOf(parentElement) >= 0 ) {
          data = data + ';' + this._valueForItem(parentElement);
        }
        e.dataTransfer.dropEffect = 'move';
        e.dataTransfer.setData('Text', data);
      },

      _onDragEnd: function(e) {
        if (e.preventDefault) e.preventDefault();
        if ( this.onDraggingClass ) 
          e.currentTarget.classList.toggle(this.onDraggingClass, false);
      },

      _onDragEnter: function(e) {
        if (e.preventDefault) {
          e.preventDefault(); 
        }
        e.currentTarget.classList.toggle('over', true);
      },

      _onDragOver: function(e) {
        e.preventDefault();
        return false
      },

      _onDragLeave: function(e) {
        e.currentTarget.classList.toggle('over', false);
      },

      _onDrop: function(e) {
        if (e.stopPropagation) 
          e.stopPropagation();

        if (e.preventDefault) 
          e.preventDefault(); 

        e.currentTarget.classList.toggle('over', false);
        
        var x = this._valueForItem(e.currentTarget);
        var y = e.dataTransfer.getData('Text').split(';')[0];

        if ( this.isMatched(x, y) ) {
          // do nothing
          return
        }

        this.match(x, y);

        return false
      },

      _onDropOut: function(e) {
        if (e.stopPropagation) 
          e.stopPropagation();

        if (e.preventDefault) 
          e.preventDefault(); 

        var data = e.dataTransfer.getData("Text").split(';');
        var y = data[0];

        if ( data.length == 2 ) {
          var x = data[1];
          if ( this._match.y.hasOwnProperty(y) 
            && this._match.y[y].indexOf(x) >= 0 ) {
            this.match(x, y);
          }
        }
      },

      match: function(xValue, yValue) {
        ASQ.MatchableBehavior.match.apply(this, [xValue, yValue]);
      },

      _onMatched: function(event) {
        var x = this._xValueToItem(event.detail.x);
        var y = this._yValueToItem(event.detail.y);

        if ( event.detail.isMatched ) {
          x.appendChild(y);
        } else {
          this._labelContainer.appendChild(y);
        }
        
      },

      submit: function() {
        if ( ! this.hasRole(this.role, this.roles.VIEWER) ) {
          return;
        }

        return {
          uid: this.uid,
          timestamp: new Date(),
          matches: this._match.x
        }
      }

    });
  </script>

</dom-module>